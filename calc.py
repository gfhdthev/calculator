primer = input('Введиле выражение: ')
for i in primer: #проверяем всю строку на пробелы
    if i == ' ': 
        primer = primer[:primer.index(i)] + primer[primer.index(i)+1:] #вырезаем каждый пробел

znaki = ['+', '-', '*', '/', '^'] #дабваляем знаки действий
prior_znaki = ['*', '/', '^']
primer = list(primer) #переводим нашу строку в список
primer1 = primer.copy() #копируем наш список
primer2 = primer.copy() #копируем наш список
tabs = [] #тут будут храниться индексы, на которых стоят знаки
posled = [] #указываем последовательность выполнения действий
k = 0 

for i in primer1:
    if i in znaki: #если элемент в знаках
        if i == '-' and primer1.index(i) == 0: #игнорируем первый минус, чтобы его не заносили в tabs
            k += 1
            primer1.remove(i)
        else:
            tabs.append(primer1.index(i)+k) #то мы добваляем его индекс + k
            k += 1 #k нам нужна, потому что, когда мы удаляем индекс, то наш список уменьшается в длину на 1 и индексы сдвигаются
            #а с помощью k мы компенсируем эти удаления
            primer1.remove(i) #и удаляем наш знак

k = 0 #очищаем переменную

for i in tabs: #перебираем индексы, на которых стоят знаки
    primer.insert(i+k+1, ' ') #добавляем пробел после этого знака
    primer.insert(i+k, ' ') #и перед
    k += 2 #l нам нужны, потому что, когда мы добавляем 2 пробела, то наш список увеличивается на 2

primer = ''.join(primer) #переаводим все в строку
primer = primer.split() #и иразделяем эту строку на числа и знаки

for i in primer2: #перебираем элементы в новом скопированном списке
    if i in prior_znaki: #если это знак приоритета
        posled.append(i) #то мы добавляем его в список
        primer2.remove(i) #и удаляем его из примера, чтобы больше его не считать

for i in primer2:
    if i in znaki: #т.к. в примере остались только + и - , то испльзуем все знаки
        posled.append(i) #и тоже добавляем их в список
        primer2.remove(i)

def sum(b: list, a: int) -> list: #создаем функцию
    res = (float(b[a-1]) + float(b[a+1])) #и делаем первое действие
    if len(b) > 3: #если длина списка позволяет
        b.pop(a+1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a-1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
    else:
        b.clear() #если не позволяет, то очищаем этот список
    b.insert(a-1, res) #и на преове место вставляем наш результат
    return b #и возвращаем наш список

def razn(b: list, a: int) -> list:
    res = (float(b[a-1]) - float(b[a+1])) #и делаем первое действие
    if len(b) > 3: #если длина списка позволяет
        b.pop(a+1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a-1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
    else:
        b.clear() #если не позволяет, то очищаем этот список
    b.insert(a-1, res) #и на преове место вставляем наш результат
    return b #и возвращаем наш список

def proisv(b: list, a: int) -> list:
    res = (float(b[a-1]) * float(b[a+1])) #и делаем первое действие
    if len(b) > 3: #если длина списка позволяет
        b.pop(a+1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a-1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
    else:
        b.clear() #если не позволяет, то очищаем этот список
    b.insert(a-1, res) #и на преове место вставляем наш результат
    return b #и возвращаем наш список

def chast(b: list, a: int) -> list:
    res = (float(b[a-1]) / float(b[a+1])) #и делаем первое действие
    if len(b) > 3: #если длина списка позволяет
        b.pop(a+1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a-1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
    else:
        b.clear() #если не позволяет, то очищаем этот список
    b.insert(a-1, res) #и на преове место вставляем наш результат
    return b #и возвращаем наш список

def stepen(b: list, a: int) -> list:
    res = (float(b[a-1]) ** float(b[a+1])) #и делаем первое действие
    if len(b) > 3: #если длина списка позволяет
        b.pop(a+1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
        b.pop(a-1) #то мы обрезаем первые 3 элемента, с которыми мы уже провели действие
    else:
        b.clear() #если не позволяет, то очищаем этот список
    b.insert(a-1, res) #и на преове место вставляем наш результат
    return b #и возвращаем наш список

for i in posled:
    for l in primer:
        if l == i: #перебираем знаки приеритета в элементах списка
            ind = primer.index(l)

            if i == '+':
                primer = sum(primer, ind) #присваеваем то, что нам возвращает функция, чтобы использовать это заново
            elif i == '-':
                primer = razn(primer, ind)
            elif i == '*':
                primer = proisv(primer, ind)
            elif i == '/':
                primer = chast(primer, ind)
            elif i == '^':
                primer = stepen(primer, ind)

print(float(primer[0])) #берем единственный элемент нашего списка и выводим его 